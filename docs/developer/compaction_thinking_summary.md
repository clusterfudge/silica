# Compaction and Extended Thinking Mode - Complete Guide

## Overview

This document provides a comprehensive guide to how Silica handles conversation compaction when extended thinking mode is enabled.

## Background: API Thinking Requirements

The Anthropic Claude API has specific requirements when extended thinking is enabled:

1. **Thinking Parameter**: When the `thinking` parameter is passed to the API, Claude can include thinking blocks in its responses
2. **Structural Requirements**: If thinking is enabled, the final assistant message MUST start with a thinking block
3. **All or Nothing**: If ANY message contains a thinking block, the thinking parameter must be enabled
4. **Ordering**: Thinking blocks must appear before other content types in specific orders

These requirements create challenges for compaction.

## The Compaction Challenge

During compaction, we want to:
- Summarize a long conversation into a shorter one
- Preserve recent context for continuity
- Maintain conversation validity for subsequent API calls

When thinking mode is enabled, we face several issues:

### Issue 1: Preserved Messages May Violate Structure
If we preserve the last few messages including assistant messages with thinking blocks:
- The API requires the LAST assistant message to start with thinking
- But we might preserve an assistant message that doesn't have thinking
- Or we might preserve multiple assistant messages in invalid order

### Issue 2: Thinking Blocks in Summary
The compaction summary is generated by a separate API call without thinking enabled:
- The summary message is from "user" role
- It doesn't have thinking blocks
- If we preserve assistant messages with thinking, we create an inconsistent structure

### Issue 3: State Mismatch After Compaction
If we strip thinking blocks but keep thinking mode enabled:
- The next API call will include the `thinking` parameter
- But the messages won't have the required thinking block structure
- API validation will fail

## The Solution: A Two-Part Approach

### Part 1: Strip All Thinking Blocks
**File**: `silica/developer/compacter.py`  
**Method**: `_strip_all_thinking_blocks()`

During compaction, we strip ALL thinking blocks from ALL preserved messages:

```python
new_messages = self._strip_all_thinking_blocks(new_messages)
```

**Why strip ALL blocks?**
- Ensures structural consistency
- Avoids complex validation rules
- Prevents API errors from invalid thinking placement
- Text content is preserved, only thinking blocks removed

**Implementation**:
```python
def _strip_all_thinking_blocks(self, messages: list) -> list:
    """Strip ALL thinking blocks from ALL messages."""
    import copy
    cleaned_messages = copy.deepcopy(messages)
    
    for message in cleaned_messages:
        if message.get("role") != "assistant":
            continue
            
        content = message.get("content", [])
        if not isinstance(content, list):
            continue
            
        # Filter out thinking blocks
        filtered_content = [
            block for block in content 
            if block.get("type") not in ["thinking", "redacted_thinking"]
        ]
        message["content"] = filtered_content
    
    return cleaned_messages
```

### Part 2: Disable Thinking Mode
**File**: `silica/developer/compacter.py`  
**Method**: `compact_conversation()`

After stripping thinking blocks, we disable thinking mode:

```python
# Disable thinking mode after stripping thinking blocks
if agent_context.thinking_mode != "off":
    agent_context.thinking_mode = "off"
```

**Why disable thinking mode?**
- Agent state must match message structure
- Prevents API validation errors on next call
- User can re-enable thinking if desired
- Graceful degradation vs. crash

### Part 3: Ensure User Message Ending (When Thinking Was Enabled)
**File**: `silica/developer/compacter.py`  
**Method**: `compact_conversation()`

When thinking mode is/was enabled, ensure conversation ends with a user message:

```python
if agent_context.thinking_mode != "off":
    if messages_to_use[-1]["role"] == "assistant":
        # Skip assistant message, find last user message
        for i in range(len(messages_to_use) - 1, -1, -1):
            if messages_to_use[i]["role"] == "user":
                new_messages.append(messages_to_use[i])
                break
```

**Why end with user message?**
- Allows next response to be from assistant with or without thinking
- Avoids needing to synthesize thinking blocks
- Cleaner conversation structure

## Complete Flow Example

### Before Compaction
```
State: thinking_mode = "normal"
Messages:
1. User: "First question"
2. Assistant: [thinking: "analyze..."] [text: "Response 1"]
3. User: "Second question"  
4. Assistant: [thinking: "consider..."] [text: "Response 2"]
... (many more messages)
```

### During Compaction
```
1. Generate summary (user message without thinking)
2. Preserve last user message: "Second question"
3. Strip all thinking blocks from preserved messages
4. Set thinking_mode = "off"
```

### After Compaction
```
State: thinking_mode = "off"
Messages:
1. User: "### Conversation Summary... Continue from this point."
2. User: "Second question"
```

### Next API Call
```
API Request:
- messages: [summary, "Second question"]
- thinking: NOT included (mode is "off")
- Response will not have thinking blocks

✅ Valid structure, no errors
```

## Test Coverage

### Test Files
1. **`test_compaction_thinking_blocks.py`**
   - Tests for stripping thinking blocks
   - Verifies text content preservation
   - Tests helper methods

2. **`test_compaction_thinking_user_message.py`**
   - Tests for ending with user message
   - Different ending scenarios (user/assistant)
   - Thinking enabled vs disabled

3. **`test_compaction_thinking_mode_state.py`** ⭐ NEW
   - Tests for thinking mode state management
   - Verifies mode disabled after compaction
   - Tests for "normal", "ultra", and "off" states
   - Prevents API validation errors

### Test Statistics
- **41 total compaction tests**
- **All tests passing**
- **Coverage for all thinking + compaction scenarios**

## User Experience

### What Users See

When compaction happens with thinking enabled:

```
[System Message]
Conversation compacted: 467 messages → 3 messages 
(archived to pre-compaction-20251101_003813.json)
```

**Behind the scenes:**
- Thinking blocks stripped from preserved messages
- Thinking mode automatically disabled
- Conversation continues without errors

### Re-enabling Thinking

Users can re-enable thinking mode after compaction:
```
/think normal    # Enable normal thinking
/think ultra     # Enable ultra thinking
```

The next response will include thinking blocks (as long as model supports it).

## Design Decisions

### Why Not Preserve Thinking Blocks?

**Considered**: Keep thinking blocks and maintain thinking mode

**Rejected because**:
- API validation rules are complex and fragile
- Would need to ensure proper structure (last message starts with thinking)
- Might preserve messages that violate other rules
- Risk of crashes vs. graceful degradation

**Benefit of stripping**:
- Simple, predictable behavior
- No risk of validation errors
- Text content preserved (thinking is internal, not user-visible)
- User can re-enable thinking if desired

### Why Not Just Disable Compaction with Thinking?

**Considered**: Disable compaction when thinking is enabled

**Rejected because**:
- Conversations would grow unbounded
- Would hit context limits
- Thinking mode is about response quality, not conversation length

**Benefit of current approach**:
- Compaction works regardless of thinking mode
- Graceful handling of mode transition
- Maintains system stability

## Future Considerations

If the Anthropic API evolves to support:
- Resuming thinking mode without previous thinking blocks
- More flexible thinking block placement
- Partial thinking block preservation

We could revisit this approach and potentially:
- Keep thinking mode enabled after compaction
- Preserve thinking blocks selectively
- Add synthetic thinking blocks

For now, the current approach prioritizes:
1. **Stability**: No crashes or API errors
2. **Predictability**: Clear state transitions
3. **User control**: Can re-enable thinking

## Related Documentation

- `compaction_thinking_blocks.md` - Original thinking block stripping implementation
- `compaction_thinking_mode_fix.md` - State management fix details
- `conversation_compaction.md` - General compaction documentation
- `extended_thinking.md` - Extended thinking mode guide

## Summary

The combination of:
1. Stripping all thinking blocks during compaction
2. Disabling thinking mode after stripping blocks  
3. Ensuring conversation ends with user message

Provides a robust, error-free compaction experience even when extended thinking mode is enabled. Users experience seamless conversation continuation with the option to re-enable thinking mode when desired.
